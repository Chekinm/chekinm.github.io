<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Writing to the page</title>
  <link rel="stylesheet" href="style.css">

  <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
  <script defer src="https://pyscript.net/latest/pyscript.js"></script>
  </head>

  <body>
  
    <input id="manual-inp" value="abbabbb">
    <button py-click="write_to_page()" id="manual">Compress with LZW</button>
    <br><span>This is dictinary</span>
    <div class="write" id="manual-write">-</div>
    <span>This is code</span>
    <div class="write" id="manual-write1">-</div> 
    <span>This is lenght of string</span>
    <div class="write" id="manual-write_len1">-</div>
    <span>This is lenght of code+dict</span>
    <div class="write" id="manual-write_len2">-</div>  <br><hr><br>


    <span>Input dictinary  here</span><br> 
    <input id="manual-inp2" value=""><br>
    <span>Input code here</span><br> 
    <input id="manual-inp3" value="">
    <button py-click="aaa()" id="manual2">Decompress LZW</button>
    <br><br><br><br>
    <span>Here is you string</span><br> 
    <div class="write" id="manual-write2"></div>


    <py-script>
def compress_lzv (string_to_compress):
    """this funciton perform LZV compression of the specified string using LZV algorithm.
    it returns compressed string.
    it supposed that string_to_compress is a finite string, not a generator, as we need to create alphabet
    for infinite stream of symbols it's better to use fixed alphabet valerian of the algorithm"""

    # create alphabet, it should include all the simbols from string_to_compress in order of appearance
    # it will be the predicate of the compressed string, as we need it to decode message back
    lzw_dict = {}
    dict_index = 0
    for i in string_to_compress:
        if i not in lzw_dict:
            lzw_dict[i] = dict_index
            dict_index += 1
    dict_to_decode = list(lzw_dict)  # we need a separate copy of the alphabet to send, better to have it as list


    # algrith LZW
    compressed_string = []  # will be a list of decimal numbers calculated using LZW method
    current_sub_string = ''
    code_to_write = None

    for i in string_to_compress:
        current_sub_string += i
        if current_sub_string in lzw_dict:
            code_to_write = lzw_dict[current_sub_string]
        else:
            compressed_string.append(code_to_write)
            lzw_dict[current_sub_string] = dict_index
            dict_index += 1
            current_sub_string = i
            code_to_write = lzw_dict[current_sub_string]
    compressed_string.append(code_to_write)   # add last portion of information



    return ''.join(dict_to_decode), ''.join(str(i) for i in compressed_string)

  
def decompress_lzv (compressed_arr, dict_lzw_inv):
    """this function perform decompression of the specified compressed package using LZV algorithm"""

    dcmp_string = ''
    right_index = 0  # index on decompressed string
    left_index = 0   # lagging index on decompressed string to restore dictionary
    i = 0            # index on compressed array
    current_sub_string = ''

    while i < len(compressed_arr):
        if left_index == right_index:
            if compressed_arr[i] < len(dict_lzw_inv):
                dcmp_string += dict_lzw_inv[compressed_arr[i]]
                right_index = len(dcmp_string)
                i += 1
            else:  # worst case, we don't have needed part of dict yet, but we know why, and can reconstruct it
                dcmp_string += dict_lzw_inv[compressed_arr[i - 1]] + dict_lzw_inv[compressed_arr[i - 1]][0]
                right_index = len(dcmp_string)
                i += 1
        current_sub_string += dcmp_string[left_index]
        if current_sub_string not in dict_lzw_inv:
            dict_lzw_inv.append(current_sub_string)
            current_sub_string = dcmp_string[left_index]
        left_index += 1
    return dcmp_string




def write_to_page():
    manual_div = Element("manual-write")
    manual_div.element.innerText = compress_lzv(Element("manual-inp").value)[0] 
    manual_div = Element("manual-write1")
    manual_div.element.innerText = compress_lzv(Element("manual-inp").value)[1] 
    
    manual_div = Element("manual-write_len1")
    manual_div.element.innerText = len(Element("manual-inp").value)
    manual_div = Element("manual-write_len2")
    manual_div.element.innerText = len(compress_lzv(Element("manual-inp").value)[0])+len(compress_lzv(Element("manual-inp").value)[1])

def aaa():
    dict = Element("manual-inp2").value
    dict1 = list(dict)
    code = Element("manual-inp3").value
    code1 = list(int(i) for i in code)
    fin_str = decompress_lzv (code1, dict1)

    manual_div = Element("manual-write2")
    manual_div.element.innerText = fin_str
    

  
    </py-script>
  </body>
</html>

